
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Resolution independent GPU text rendering demo</title>
<style type="text/css">

	html, body {
		width: 100%;
		height: 100%
		margin 0;
		padding: 0;
		overflow: hidden;
		font-family: sans-serif;
		-khtml-user-select: none;
		-o-user-select: none;
		-moz-user-select: -moz-none;
		-webkit-user-select: none;
	}


	a {
		color: white;
	}

	a:hover {
		color: #ffd;
	}

	div#canvaswrap {
		position: fixed;
		zoom: reset;
		right: 0;
		bottom: 0;
		top: 0;
		left: 0;
		z-index: -1;
	}

	div#toolbar {
		margin: 0;
		right: 0;
		position: absolute;
		display: inline-block;
		max-width: 22em;
		background-color: rgba(0, 0, 0, .6);
		color: white;
		padding: 1em;
	}

	canvas {
		width: 100%;
		height: 100%;
		display: none;	/* need this to force reflow on first frame by changing to block */
		zoom: reset;
	}

	#loadinginfo {
		position: absolute;
		top: 50%;
		left: 50%;
		margin-top: -100px;
		margin-left: -150px;
		width: 300px;
		height: 200px;
		background-color: white;
		color: black;
		white-space: pre-wrap;
		padding: 1em;
		overflow: auto;
	}

	@media screen and (max-width: 600px) {
		#fsbutton { display: none;}
	}
</style>
<script type="x-shader/x-vertex" id="glyphvs">
//insertdefines
uniform sampler2D uAtlasSampler;
uniform vec2 uTexelSize;
uniform vec2 uPositionMul;
uniform vec2 uPositionAdd;

attribute vec2 aPosition;
attribute vec2 aCurvesMin;
attribute vec4 aColor;

varying vec2 vCurvesMin;
varying vec2 vGridMin;
varying vec2 vGridSize;
#ifdef kUseRasteredAtlas
varying vec2 vRasteredGridMin;
varying vec2 vRasteredGridSize;
#endif
varying vec2 vNormCoord;
varying vec4 vColor;

#define kGlyphPaddingFactor 1.4

// Get non-normalised number in range 0-65535 from two channels of a texel
float ushortFromVec2(vec2 v) {
	// v.x holds most significant bits, v.y holds least significant bits
	return 65280.0 * v.x + 255.0 * v.y;
}

vec2 fetchVec2(vec2 coord) {
	vec2 ret;
	vec4 tex = texture2D(uAtlasSampler, (coord + 0.5) * uTexelSize);

	ret.x = ushortFromVec2(tex.rg);
	ret.y = ushortFromVec2(tex.ba);
	return ret;
}

void decodeUnsignedShortWithFlag(vec2 f, out vec2 x, out vec2 flag) {
	x = floor(f * 0.5);
	flag = mod(f, 2.0);
}

vec2 rot90(vec2 v) {
	return vec2(v.y, -v.x);
}

void main() {

	vColor = aColor;

	decodeUnsignedShortWithFlag(aCurvesMin, vCurvesMin, vNormCoord);
	vGridMin = fetchVec2(vCurvesMin);
	vec4 sizes = texture2D(uAtlasSampler, vec2(vCurvesMin.x + 2.5, vCurvesMin.y + 0.5) * uTexelSize) * 255.0;
	vGridSize = sizes.rg;
	vec2 rasteredGridSize = sizes.ba;

	#ifdef kUseRasteredAtlas
	vRasteredGridMin = fetchVec2(vec2(vCurvesMin.x + 1.0, vCurvesMin.y));
	vRasteredGridSize = rasteredGridSize;
	#endif
	
	// Adjust vNormCoord to compensate for expanded glyph bounding boxes
	bool ylarger = rasteredGridSize.x < rasteredGridSize.y;
	if (ylarger) rasteredGridSize = rasteredGridSize.yx;
	vec2 expandFactor = vec2(kGlyphPaddingFactor, (rasteredGridSize.y + rasteredGridSize.x * (kGlyphPaddingFactor - 1.0)) / rasteredGridSize.y);
	if (ylarger) expandFactor = expandFactor.yx;
	vNormCoord = (vNormCoord - 0.5) * expandFactor + 0.5;

	// Transform position
	vec2 pos = aPosition + 0.5;
	pos.y = 1.0 - pos.y;
	pos = pos * uPositionMul + uPositionAdd;

	gl_Position = vec4(pos, 0.0, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="glyphfs">
#extension GL_OES_standard_derivatives : enable
precision highp float;

#define numSS 4
#define pi 3.1415926535897932384626433832795
#define kPixelWindowSize 1.0
//insertdefines

uniform sampler2D uAtlasSampler;
uniform vec2 uTexelSize;
uniform int uDebug;

varying vec2 vCurvesMin;
varying vec2 vGridMin;
varying vec2 vGridSize;
varying vec2 vNormCoord;
varying vec4 vColor;

#ifdef kUseRasteredAtlas
uniform vec2 uRasteredTexelSize;
uniform sampler2D uRasteredAtlasSampler;
varying vec2 vRasteredGridMin;
varying vec2 vRasteredGridSize;
#endif

float positionAt(float p0, float p1, float p2, float t) {
    float mt = 1.0 - t;
    return mt*mt*p0 + 2.0*t*mt*p1 + t*t*p2;
}

float tangentAt(float p0, float p1, float p2, float t) {
    return 2.0 * (1.0-t) * (p1 - p0) + 2.0 * t * (p2 - p1);
}

bool almostEqual(float a, float b) {
    return abs(a-b) < 1e-5;
}

float normalizedUshortFromVec2(vec2 v) {
    // produces value in (0,1) range from a vec2
    // vec2 is assumed to come from two unsigned bytes, where v.x is the most significant byte and v.y is the least significant

    // equivalent to this:
    // return (v.x * 65280.0 + vec2.y * 255.0) / 65535.0;

    return (256.0/257.0) * v.x + (1.0/257.0) * v.y;

}    

vec2 fetchVec2(vec2 coord) {
    vec2 ret;
    vec4 tex = texture2D(uAtlasSampler, (coord + 0.5) * uTexelSize);
    ret.x = normalizedUshortFromVec2(tex.rg);
    ret.y = normalizedUshortFromVec2(tex.ba);
    return ret;
}

void fetchBezier(int coordIndex, out vec2 p[3]) {
    for (int i=0; i<3; i++) {
        p[i] = fetchVec2(vec2(vCurvesMin.x + float(coordIndex + i + 1), vCurvesMin.y)) - vNormCoord;
    }
}

int getAxisIntersections(float p0, float p1, float p2, out vec2 t) {
    if (almostEqual(p0, 2.0*p1 - p2)) {
        t[0] = 0.5 * (p2 - 2.0*p1) / (p2 - p1);
        return 1;
    }

    float sqrtTerm = p1*p1 - p0*p2;
    if (sqrtTerm < 0.0) return 0;
    sqrtTerm = sqrt(sqrtTerm);
    float denom = p0 - 2.0*p1 + p2;
    t[0] = (p0 - p1 + sqrtTerm) / denom;
    t[1] = (p0 - p1 - sqrtTerm) / denom;
    return 2;
}

float integrateWindow(float x) {
    float xsq = x*x;
    return sign(x) * (0.5 * xsq*xsq - xsq) + 0.5;           // parabolic window
    //return 0.5 * (1.0 - sign(x) * xsq);                     // box window
}

mat2 getUnitLineMatrix(vec2 b1, vec2 b2) {
    vec2 V = b2 - b1;
    float normV = length(V);
    V = V / (normV*normV);

    return mat2(V.x, -V.y, V.y, V.x);
}

void updateClosestCrossing(in vec2 porig[3], mat2 M, inout float closest, vec2 integerCell) {

	vec2 p[3];
    for (int i=0; i<3; i++) {
        p[i] = M * porig[i];
    }

    vec2 t;
    int numT = getAxisIntersections(p[0].y, p[1].y, p[2].y, t);

    for (int i=0; i<2; i++) {
        if (i == numT) break;
        if (t[i] > 0.0 && t[i] < 1.0) {
            float posx = positionAt(p[0].x, p[1].x, p[2].x, t[i]);
            vec2 op = vec2(positionAt(porig[0].x, porig[1].x, porig[2].x, t[i]),
            			   positionAt(porig[0].y, porig[1].y, porig[2].y, t[i]));
            op += vNormCoord;

            bool sameCell = floor( clamp(op * vGridSize, vec2(0.5), vec2(vGridSize)-0.5)) == integerCell;

            //if (posx > 0.0 && posx < 1.0 && posx < abs(closest)) {
        	if (sameCell && abs(posx) < abs(closest)) {
                float derivy = tangentAt(p[0].y, p[1].y, p[2].y, t[i]);
                closest = (derivy < 0.0) ? -posx : posx;
            }
        }
    }
}

mat2 inverse(mat2 m) {
  return mat2(m[1][1],-m[0][1],
             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
}


void render() {

#ifdef kUseRasteredAtlas
	vec2 nc = vec2(vNormCoord.x, 1.0 - vNormCoord.y) * vRasteredGridSize;

	if (min(fwidth(nc.x), fwidth(nc.y)) > 2.0) {
		vec2 dx = dFdx(nc) * 0.33 * uRasteredTexelSize;
		vec2 dy = dFdy(nc) * 0.33 * uRasteredTexelSize;
	    gl_FragColor = vColor;
	    vec2 rcoord = (vRasteredGridMin + nc) * uRasteredTexelSize;
	    rcoord.y = 1.0 - rcoord.y;
	    
	    /*
		    // 4 samples in square shape
		    float bias = -2.0;
		    gl_FragColor.a *= 0.25 * (
							    texture2D(uRasteredAtlasSampler, rcoord - dx - dy, bias).r +
							    texture2D(uRasteredAtlasSampler, rcoord - dx + dy, bias).r +
							    texture2D(uRasteredAtlasSampler, rcoord + dx - dy, bias).r +
							    texture2D(uRasteredAtlasSampler, rcoord + dx + dy, bias).r
							);

		*/
		// 5 samples in X shape
	    float bias = -2.0;
	    gl_FragColor.a *= 1.0/3.0 * texture2D(uRasteredAtlasSampler, rcoord, bias).r +
					     1.0/6.0 * (
						    texture2D(uRasteredAtlasSampler, rcoord - dx - dy, bias).r +
						    texture2D(uRasteredAtlasSampler, rcoord - dx + dy, bias).r +
						    texture2D(uRasteredAtlasSampler, rcoord + dx - dy, bias).r +
						    texture2D(uRasteredAtlasSampler, rcoord + dx + dy, bias).r
						);

		return;
	}

#endif	

    vec2 integerCell = floor( clamp(vNormCoord * vGridSize, vec2(0.5), vec2(vGridSize)-0.5));
    vec2 indicesCoord = vGridMin + integerCell + 0.5;
    vec2 cellMid = (integerCell + 0.5) / vGridSize;

    mat2 initrot = inverse(mat2(dFdx(vNormCoord) * kPixelWindowSize, dFdy(vNormCoord) * kPixelWindowSize));

    float theta = pi/float(numSS);
    mat2 rotM = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));      // note this is column major ordering

    ivec4 indices1, indices2;
    indices1 = ivec4(texture2D(uAtlasSampler, indicesCoord * uTexelSize) * 255.0 + 0.5);
    indices2 = ivec4(texture2D(uAtlasSampler, vec2(indicesCoord.x + vGridSize.x, indicesCoord.y) * uTexelSize) * 255.0 + 0.5);

    bool moreThanFourIndices = indices1[0] < indices1[1];

    float midClosest = (indices1[2] < indices1[3]) ? -2.0 : 2.0;

	
    float closestEndPoint = 100.0;
    float closestOffCurvePoint = 100.0;


    float firstIntersection[numSS];
    for (int ss=0; ss<numSS; ss++) {
        firstIntersection[ss] = 2.0;
    }

    float percent = 0.0;

    mat2 midTransform = getUnitLineMatrix(vNormCoord, cellMid);

    for (int bezierIndex=0; bezierIndex<8; bezierIndex++) {
        int coordIndex;

        if (bezierIndex < 4) {
            coordIndex = indices1[bezierIndex];
        } else {
            if (!moreThanFourIndices) break;
            coordIndex = indices2[bezierIndex-4];
        }

        if (coordIndex < 2) {
            continue;
        }

        vec2 p[3];
        fetchBezier(coordIndex, p);

        updateClosestCrossing(p, midTransform, midClosest, integerCell);

        // Transform p so fragment in glyph space is a unit circle
        for (int i=0; i<3; i++) {
            p[i] = initrot * p[i];
        }

        if (uDebug != 0) {
	        closestEndPoint = min(min(closestEndPoint, dot(p[0], p[0])), dot(p[2], p[2]));
	        closestOffCurvePoint = min(closestOffCurvePoint, dot(p[1], p[1]));
    	}

        // Iterate through angles
        for (int ss=0; ss<numSS; ss++) {
            vec2 t;
            int numT = getAxisIntersections(p[0].x, p[1].x, p[2].x, t);

            for (int tindex=0; tindex<2; tindex++) {
                if (tindex == numT) break;

                if (t[tindex] > 0.0 && t[tindex] <= 1.0) {

                    float derivx = tangentAt(p[0].x, p[1].x, p[2].x, t[tindex]);
                    float posy = positionAt(p[0].y, p[1].y, p[2].y, t[tindex]);

                    if (posy > -1.0 && posy < 1.0) {
                        // Note: whether to add or subtract in the next statement is determined
                        // by which convention the path uses: moving from the bezier start to end, 
                        // is the inside to the right or left?
                        // The wrong operation will give buggy looking results, not a simple inverse.
                        float delta = integrateWindow(posy);
                        percent = percent + (derivx < 0.0 ? delta : -delta);

                        float intersectDist = posy + 1.0;
                        if (intersectDist < abs(firstIntersection[ss])) {
                            firstIntersection[ss] = derivx < 0.0 ? -intersectDist : intersectDist;
                        }
                    }
                }
            }

            if (ss+1<numSS) {
                for (int i=0; i<3; i++) {
                    p[i] = rotM * p[i];
                }
            }
        }   // ss
    }

    bool midVal = midClosest < 0.0;

    // Add contribution from rays that started inside
    for (int ss=0; ss<numSS; ss++) {
        if ((firstIntersection[ss] >= 2.0 && midVal) || (firstIntersection[ss] > 0.0 && abs(firstIntersection[ss]) < 2.0)) {
            percent = percent + 1.0 /*integrateWindow(-1.0)*/;
        }
    }

    percent = percent / float(numSS);
	gl_FragColor = vColor;
	gl_FragColor.a *= percent;
	


	if (uDebug != 0) {
		vec2 gridCell = mod(floor(integerCell), 2.0);
		gl_FragColor.a += 0.5 * (gridCell.x - gridCell.y) * (gridCell.x - gridCell.y);
		if (moreThanFourIndices) {
			gl_FragColor.a *= 0.5 + 0.5 * mod(gl_FragCoord.x, 2.0);
		}

		gl_FragColor.g += 1.0 - smoothstep(sqrt(closestEndPoint), 0.0, 3.0);
		gl_FragColor.r += 1.0 - smoothstep(sqrt(closestOffCurvePoint), 0.0, 3.0);
		gl_FragColor.a = max(gl_FragColor.a, max(gl_FragColor.g, gl_FragColor.r));
		#ifdef kUseRasteredAtlas
			//gl_FragColor = texture2D(uRasteredAtlasSampler, vNormCoord);
		#endif
	}

}


void main() {
	render();	
}

</script>
<script type="x-shader/x-vertex" id="pagevs">
	uniform vec2 uPositionMul;
	uniform vec2 uPositionAdd;

	attribute vec2 aPosition;

	void main() {
		// Transform position
		vec2 pos = aPosition;
		pos.y = 1.0 - pos.y;
		pos = pos * uPositionMul + uPositionAdd;

		gl_Position = vec4(pos, 0.0, 1.0);
	}
</script>
<script type="x-shader/x-fragment" id="pagefs">
	void main() {
		gl_FragColor = vec4(1.0);
	}
</script>
<script type="x-shader/x-vertex" id="imagevs">
	uniform vec2 uPositionMul;
	uniform vec2 uPositionAdd;

	attribute vec2 aPosition;
	attribute vec2 aTexCoord;
	attribute float aAlpha;
	attribute float aInvert;

	varying float vAlpha;
	varying vec2 vTexCoord;

	void main() {
		vTexCoord = aTexCoord;
		vAlpha = aInvert > 0.0 ? -aAlpha : aAlpha;

		// Transform position
		vec2 pos = aPosition;
		pos.y = 1.0 - pos.y;
		pos = pos * uPositionMul + uPositionAdd;
		gl_Position = vec4(pos, 0.0, 1.0);
	}
</script>
<script type="x-shader/x-fragment" id="imagefs">
	precision highp float;
	uniform sampler2D uSampler;

	varying vec2 vTexCoord;
	varying float vAlpha;

	void main() {
		gl_FragColor = texture2D(uSampler, vTexCoord);
		//if (vAlpha < 0.0) gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;
		gl_FragColor.a *= abs(vAlpha);
	}
</script>

<script>
	"use strict";
	var canvas;
	var gl;
	var glext;
	var timerQuery, waitingForTimer, lastFrametime;
	var glyphProgram, glyphProgramNoRast, pageProgram, imageProgram;
	var atlasTexture;
	var glyphBuffer;
	var pageBuffer;
	var imageBuffer;
	var pageData;
	var indexCount = 0;
	var int16PerVertex = 6;	// const
	var int16PerGlyph = 10;
	var imageTextures = {};
	var preAtlasTexture;
	var positions = {x:[], y:[]};		// for auto zoom
	var mustRenderNextFrame = false;

	function ushortWithFlag(x, flag) {
		return (x|0)*2 + (flag ? 1 : 0)
	}

	function roundUpToPowerOfTwo(x) {
			//return Math.pow(2, Math.floor(Math.log(x, 2)) + 1);
			x--;
			for (var i=1; i<32; i *= 2) {
				x |= x >> i;
			}
			return ++x;
	}

	function resizeImageToPowerOfTwo(image) {
		var width = roundUpToPowerOfTwo(image.width);
		var height = roundUpToPowerOfTwo(image.height);

		if (width == image.width && height == image.height) {
			return image;
		}

		var cv = document.createElement("canvas");
		var ctx = cv.getContext("2d");
		cv.width = width;
		cv.height = height;
		ctx.drawImage(image, 0, 0, width, height);
		return cv;
	}

	function imageTextureReady(handle, image) {
		gl.bindTexture(gl.TEXTURE_2D, handle);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);		// TODO: should be true for proper mipmap
		//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, resizeImageToPowerOfTwo(image));
		gl.hint(gl.GENERATE_MIPMAP_HINT, gl.FASTEST);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);
		handle.ready = true;
		forceAnimationChange();
	}

	function getImageTexture(filename) {
		var handle = imageTextures[filename];
		if (!handle) {
			var handle = gl.createTexture();
			var img = new Image();
			img.src = "images/" + filename;
			img.onload = function() { imageTextureReady(handle, img) }
			imageTextures[filename] = handle;
			return null;
		}

		if (!handle.ready) {
			return null;
		}

		return handle;
	}

	var transform = {
		x: 0.5,
		y: 0.5,
		zoom: 2
	}

	var animTransform = {
		x: 0,
		y: 0,
		zoom: 2
	}
	
	var lastAnimationTimestamp;
	var animationDuration = 60;

	function mix(b, a, t) {
		if (t < 0) t = 0;
		else if (t > 1) t = 1;
		
		return a * t + b * (1 - t);
	}
	
	function log(s) {
		console.log(s);
		document.getElementById("loadinginfo").textContent += s + "\n";
	}

	function approxEqual(a, b) {
		return Math.abs(a - b) < 0.00000001;

		/*
		if (Math.abs(b) < Math.abs(a)) {
			var t = b;
			b = a;
			a = t;
		}
		var threshhold = 0.99999999
		if (b == 0) return a == b;
		return (a/b) > threshhold;
		*/
	}

	function getAnimatedValue(value, target, elapsed) {
		if (isNaN(value)) return target;
		
		var newval = mix(value, target, elapsed / animationDuration);
		if (approxEqual(newval, target)) {
			// snap to target if we're close
			newval = target;
		}
		return newval;
	}
	
	function updateAnimations(timestamp) {
		var elapsed = lastAnimationTimestamp ? timestamp - lastAnimationTimestamp : 0;
		
		var changed = mustRenderNextFrame;
		mustRenderNextFrame = false;
		for (var key in animTransform) {
			if (isNaN(transform[key])) {
				transform[key] = 0.5;
			}

			var newval = getAnimatedValue(animTransform[key], transform[key], elapsed);
			if (newval != animTransform[key]) {
				changed = true;
			}
			animTransform[key] = newval;
		}
		
		lastAnimationTimestamp = timestamp;

		return changed;
	}

	function finishAnimations() {
		for (var key in animTransform) {
			animTransform[key] = transform[key];
		}
		forceAnimationChange();
	}

	function forceAnimationChange() {
		mustRenderNextFrame = true;
	}
	
	function initGl() {
		// need alpha: false so what's behind the webgl canvas doesn't bleed through
		// see http://www.zovirl.com/2012/08/24/webgl_alpha/
		var flags = {
		 	alpha: false,
			antialias: false,
			depth: false,
			stencil: false,
			preserveDrawingBuffer: false,
		}
		gl = canvas.getContext("webgl", flags);
		if (gl == null) {
			gl = canvas.getContext("experimental-webgl", flags);
			if (gl == null) {
				log("Failed to create WebGL context");
				return;
			}
		}

        if (gl.getExtension('OES_standard_derivatives') == null) {
            log("Failed to enable required WebGL extension OES_standard_derivatives");
            return;
        }

        glext = gl.getExtension('EXT_disjoint_timer_query');
        if (glext) {
        	timerQuery = glext.createQueryEXT();
        	document.getElementById("frametime").style.display = "inline";
        }

		gl.disable(gl.DEPTH_TEST);

		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);   

		gl.viewport(0, 0, canvas.width, canvas.height);
	}


	function compileShaderFromElement(id, defines) {
		var elem = document.getElementById(id);
		if (!elem) {
			log("Can't find shader element " + id);
			return null;
		}
		var shaderType;
		if (elem.type == "x-shader/x-vertex") {
			shaderType = gl.VERTEX_SHADER;
		} else if (elem.type == "x-shader/x-fragment") {
			shaderType = gl.FRAGMENT_SHADER;
		} else {
			log("getShader: unknown shader type in script tag for id " + id);
			return;
		}

		var src = elem.textContent;
		if (defines != null) {
			src = src.replace("//insertdefines", defines);
		}

		var shader = gl.createShader(shaderType);
		
		gl.shaderSource(shader, src);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			log("Failed to compile shader '" + id + "':\n" + gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	}

    function createProgram(vid, fid, defines) {
    	var vshader = compileShaderFromElement(vid, defines);
		var fshader = compileShaderFromElement(fid, defines);

		if (vshader == null || fshader == null) {
			return;
		}

		var program = gl.createProgram();
		gl.attachShader(program, vshader);
		gl.attachShader(program, fshader);
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			log("Could not link program for shaders " +  vid + " and " + fid + ": " + gl.getProgramInfoLog(program));
			gl.deleteProgram(imageProgram);
			return;
		}

		//var translatedSource = gl.getExtension("WEBGL_debug_shaders").getTranslatedShaderSource(fshader);

		var nattrib = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		program.attributes = {};
		for (var i=0; i<nattrib; i++) {
			var name = gl.getActiveAttrib(program, i).name;
			program.attributes[name] = gl.getAttribLocation(program, name);
		}

		var nuniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		program.uniforms = {};
		for (var i=0; i<nuniforms; i++) {
			var name = gl.getActiveUniform(program, i).name;
			program.uniforms[name] = gl.getUniformLocation(program, name);
		}

		return program;
    }

	function processPageData() {
		pageData = JSON.parse(this.responseText);
		log("Loaded " + pageData.length + " page(s)")
		computePageLocations();
		var pageVerts = new Float32Array(pageData.length * 6 * 2);

		for (var i=0; i<pageData.length; i++) {
			var j = i*6*2;
			var x0 = -pageData[i].x;
			var y0 = pageData[i].y;
			var x1 = x0 + pageData[i].width / pageData[0].width;
			var y1 = y0 + pageData[i].height / pageData[0].height;
			pageVerts[j+ 0] = x0;
			pageVerts[j+ 1] = y0;
			pageVerts[j+ 2] = x0;
			pageVerts[j+ 3] = y0;
			pageVerts[j+ 4] = x1;
			pageVerts[j+ 5] = y0;
			pageVerts[j+ 6] = x0;
			pageVerts[j+ 7] = y1;
			pageVerts[j+ 8] = x1;
			pageVerts[j+ 9] = y1;
			pageVerts[j+10] = x1;
			pageVerts[j+11] = y1;
		}
		pageBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, pageBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, pageVerts, gl.STATIC_DRAW);
	}

	function requestFile(filename, cb, rtype) {
        var req = new XMLHttpRequest();
        req.open("GET", uncached(filename), true);
        req.onload = cb;
        if (rtype) {
        	req.responseType = rtype;
        }
        req.send(null);
	}
	
	function enableAttributes(prog) {
		for (var a in prog.attributes) {
			gl.enableVertexAttribArray(prog.attributes[a])
		}
	}

	function disableAttributes(prog) {
		for (var a in prog.attributes) {
			gl.disableVertexAttribArray(prog.attributes[a]);
		}
	}

	function unpackBmp(buf) {
		// TODO: endian issues
		var iarr = new Uint16Array(buf, 18, 4);
		return {buf: buf.slice(54), width: iarr[0], height: iarr[2]};
	}
	
	function processAtlas() {
		var data = unpackBmp(this.response);
		var arrayView = new Uint8Array(data.buf);
		atlasTexture = gl.createTexture();
		atlasTexture.width = data.width;
		atlasTexture.height = data.height;
		gl.bindTexture(gl.TEXTURE_2D, atlasTexture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
		//gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, atlasTexture.width, atlasTexture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, arrayView);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);		

		gl.bindTexture(gl.TEXTURE_2D, null);
		log("Loaded atlas: " + atlasTexture.width + " x " + atlasTexture.height);

		requestFile('atlasverts.bmp', processAtlasVertices, 'arraybuffer');
	}

	function transposeBytes(buf, innerDim) {
		var inputArray = new Uint8Array(buf);
		var outputArray = new Uint8Array(inputArray.length);

		var outerDim = inputArray.length / innerDim;

		for (var i=0; i<innerDim; i++) {
			for (var j=0; j<outerDim; j++) {
				outputArray[j * innerDim + i] = inputArray[i * outerDim + j];
			}
		}

		return outputArray.buffer;
	}

	function boxesIntersect(a, b) {
		return a.x0 < b.x1 && a.y0 < b.y1 && a.x1 > b.x0 && a.y1 > b.y0;
	}

	function processGlyphs() {
		var data = unpackBmp(this.response);
		var uposition = new  Int16Array(data.buf, 0);
		var position  = new  Int16Array(data.buf, 0);
		var curvesMin = new Uint16Array(data.buf, 4);
		var deltaNext = new  Int16Array(data.buf, 8);
		var deltaPrev = new  Int16Array(data.buf, 12);
		var color 	  = new Uint16Array(data.buf, 16);

		var numGlyphs = data.buf.byteLength / (2 * int16PerGlyph);
		log("Loaded " + numGlyphs + " glyphs");

		var vbuf = new ArrayBuffer(numGlyphs * 6 * int16PerVertex * 2);
		var oPosition  = new Int16Array(vbuf, 0);
		var oCurvesMin = new Uint16Array(vbuf, 4);
		var oColor      = new Uint16Array(vbuf, 8);

		positions.x = new Float32Array(numGlyphs);
		positions.y = new Float32Array(numGlyphs);

		var src=0, dst=0;
		for (var i=0; i<numGlyphs; i++) {

			// delta decode
			if (i > 0) {
				position[src+0] += position[src-int16PerGlyph+0];
				position[src+1] += position[src-int16PerGlyph+1];
			}

			positions.x[i] = (uposition[src+0] + 0.5 * (deltaNext[src+0] + deltaPrev[src+0])) / 32767 + 0.5;
			positions.y[i] = (uposition[src+1] + 0.5 * (deltaNext[src+1] + deltaPrev[src+1])) / 32767 + 0.5;

			// output tri strip quad
			for (var j=0; j<6; j++) {
				var k = (j < 4) ? j : 6 - j;	// 0, 1, 2, 3, 2, 1
				//var k = Math.min(3, Math.max(0, j - 1));		// 0, 0, 1, 2, 3, 3

				oPosition[dst+0]  = position[src+0];
				oPosition[dst+1]  = position[src+1];

				if (k == 1) {
					oPosition[dst+0] += deltaNext[src+0];
					oPosition[dst+1] += deltaNext[src+1];
				} else if (k == 2) {
					oPosition[dst+0] += deltaPrev[src+0];
					oPosition[dst+1] += deltaPrev[src+1];
				} else if (k == 3) {
					oPosition[dst+0] += deltaNext[src+0] + deltaPrev[src+0];
					oPosition[dst+1] += deltaNext[src+1] + deltaPrev[src+1];
				}

				oCurvesMin[dst+0] = ushortWithFlag(curvesMin[src+0], k & 1);
				oCurvesMin[dst+1] = ushortWithFlag(curvesMin[src+1], k > 1);
				oColor[dst+0]     = color[src+0];
				oColor[dst+1]     = color[src+1];

				if (i<10) {
					//console.log(i, j, oPosition[dst+0], oPosition[dst+1], positions.x[i], positions.y[i]);
				}

				dst += int16PerVertex;
			}

			src += int16PerGlyph;
		}

		glyphBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, glyphBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, vbuf, gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
	}


	function doGlyphVertexAttribPointers(prog) {
		var stride = int16PerVertex*2;
		gl.vertexAttribPointer(prog.attributes.aPosition, 			2, gl.SHORT,   		  true,  stride,  0);
		gl.vertexAttribPointer(prog.attributes.aCurvesMin, 			2, gl.UNSIGNED_SHORT, false, stride,  2*2);
		gl.vertexAttribPointer(prog.attributes.aColor,     			4, gl.UNSIGNED_BYTE,  true,  stride,  4*2);
	}

	function processAtlasVertices() {
		var data = unpackBmp(this.response);
		var handle = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, handle);
		gl.bufferData(gl.ARRAY_BUFFER, data.buf, gl.STREAM_DRAW);

		//console.log("Atlas vert buf is " + data.buf.byteLength + " bytes, this is " + data.buf.byteLength / (6 * 2 * int16PerVertex) + " glyphs");

		// framebuffer object
		var fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		fbo.width = data.width;
		fbo.height = data.height;

		preAtlasTexture = gl.createTexture();
		preAtlasTexture.width = data.width;
		preAtlasTexture.height = data.height;
		gl.bindTexture(gl.TEXTURE_2D, preAtlasTexture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);		
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbo.width, fbo.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		gl.generateMipmap(gl.TEXTURE_2D);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, preAtlasTexture, 0);
	    gl.bindTexture(gl.TEXTURE_2D, null);

	    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
	    if (status != gl.FRAMEBUFFER_COMPLETE) {
	    	console.log("checkFrameBufferStatus(gl.FRAMEBUFFER) not complete!");
	    }

	    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	    gl.viewport(0, 0, fbo.width, fbo.height);

	    gl.clearColor(0, 0, 0, 1);
	    gl.clear(gl.COLOR_BUFFER_BIT);

		gl.useProgram(glyphProgramNoRast);

		gl.enable(gl.BLEND);
		gl.disable(gl.DEPTH_TEST);
		gl.depthMask(gl.FALSE);
		
		enableAttributes(glyphProgramNoRast);
		doGlyphVertexAttribPointers(glyphProgramNoRast);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, atlasTexture);

		gl.uniform1i(glyphProgramNoRast.uniforms.uAtlasSampler, 0);
		gl.uniform2f(glyphProgramNoRast.uniforms.uTexelSize, 1/atlasTexture.width, 1/atlasTexture.height);
		gl.uniform1i(glyphProgramNoRast.uniforms.uDebug, 0);

		// Need to map [0, 1] verts to [-1, 1] NDC, ie: aPosition * 2.0 - 1.0
		gl.uniform2f(glyphProgramNoRast.uniforms.uPositionMul, 2, 2);
		gl.uniform2f(glyphProgramNoRast.uniforms.uPositionAdd, -1, -1);

		gl.drawArrays(gl.TRIANGLES, 0, data.buf.byteLength / (2 * int16PerVertex));

		disableAttributes(glyphProgramNoRast);

		gl.useProgram(null);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		gl.bindTexture(gl.TEXTURE_2D, preAtlasTexture);
		gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);

		gl.deleteBuffer(handle);
	}


	function processImageVertices() {
		var buf = unpackBmp(this.response).buf;
		imageBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, imageBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, buf, gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		console.log("Loaded image vertex buffer: " + buf.byteLength + " bytes, this is " + buf.byteLength / 10 / 6 + " images");
	}
	
	function setCanvasSize() {
		var devicePixelRatio = window.devicePixelRatio || 1;
		if (window.innerWidth && window.outerWidth) {
			devicePixelRatio *= window.innerWidth / window.outerWidth;
		}

		var e = document.getElementById("canvaswrap");
		var w = Math.round(e.clientWidth * devicePixelRatio);
		var h = Math.round(e.clientHeight * devicePixelRatio);

		if (canvas.width != w || canvas.height != h) {
			canvas.width = w;
			canvas.height = h;
		}		
	}

	function setPageUniforms(program, page, zoomx, zoomy) {
		// Shader would have done:
		//pos = (pos - uTranslate) / uZoom;
		//So, pos * (1/uZoom) + (-uTranslate/uZoom);
		var translateX = page.x + animTransform.x;
		var translateY = page.y + animTransform.y;

		var pageNdc = {
			x0: (0 - translateX) / zoomx * canvas.height / canvas.width,
			x1: (1 - translateX) / zoomx * canvas.height / canvas.width,
			y0: (0 - translateY) / zoomy,
			y1: (1 - translateY) / zoomy,
		}
		var viewportNdc = {
			x0: -1,
			x1:  1,
			y0: -1,
			y1:  1,
		}
		if (!boxesIntersect(pageNdc, viewportNdc)) {
			return false;
		}

		var aspect = canvas.height / canvas.width;

		gl.uniform2f(program.uniforms.uPositionMul, aspect/zoomx, 1/zoomy);
		gl.uniform2f(program.uniforms.uPositionAdd, aspect * -translateX / zoomx, -translateY / zoomy);

		return true;
	}
	
	function computePageLocations() {
		var cols = Math.floor(Math.sqrt(pageData.length / canvas.height * canvas.width / pageData[0].width * pageData[0].height));

		for (var i=0; i<pageData.length; i++) {
			var page = pageData[i];
			page.x = -(i % cols);
			page.y = Math.floor(i / cols);

			var gap = 1.06;
			page.x *= gap;
			page.y *= gap;
		}		

	}

	function lerp(from, to, t) {
		return (to - from) * t + from;
	}
	
	function doubleExponentialSigmoid(x, a) {
		var epsilon = 0.00001;
		var min_param_a = 0.0 + epsilon;
		var max_param_a = 1.0 - epsilon;
		a = Math.min(max_param_a, Math.max(min_param_a, a));
		a = 1.0-a; // for sensible results
		
		var y = 0;
		if (x<=0.5) {
			y = (Math.pow(2.0*x, 1.0/a))/2.0;
		} else {
			y = 1.0 - (Math.pow(2.0*(1.0-x), 1.0/a))/2.0;
		}
		return y;
	}
	
	function blend(from, to, t, a) {
		if (a == null) a = 0.9;
		return lerp(from, to, doubleExponentialSigmoid(t, a));
	}
	
	var lastAutoChange = -1e6;
	var panFromX = 0, panFromY = 0, panToX = 0, panToY = 0;
	function drawScene(timestamp) {

		if (glyphProgram == null || !glyphBuffer || !pageData || !atlasTexture || !preAtlasTexture) {
			return;
		}
		var firstFrame = document.getElementById("loadinginfo").style.visibility != "hidden";
		if (firstFrame) {
			document.getElementById("loadinginfo").style.visibility = "hidden";
			canvas.style.display = "block";	// force reflow on ios
		}

		var zoomx = animTransform.zoom;
		var zoomy = zoomx * pageData[0].width / pageData[0].height;

		var autoPan = document.getElementById("autopan").checked;
		if (autoPan) {
			var interval = 14000;
			if (timestamp - lastAutoChange > interval) {
				lastAutoChange = timestamp;
				var page = pageData[Math.floor(Math.random() * pageData.length)];
				var glyph = Math.floor(Math.random() * (page.endVertex - page.beginVertex)) + page.beginVertex;
				glyph = Math.floor(glyph/6);
				
				panFromX = panToX;
				panFromY = panToY;
				
				panToX = -page.x + positions.x[glyph];
				panToY = -page.y + 1.0 - positions.y[glyph];
			}
			
			var t = (timestamp - lastAutoChange) / interval;

			var zoomin = Math.pow(2, -7);
			var zoomout = Math.pow(2, 1.5);
			var clip = 0.3;
			var za = 0.8;
			if (t < clip) {
				transform.zoom = blend(zoomin, zoomout, t/clip, za);
			} else if (t > 1.0 - clip) {
				transform.zoom = blend(zoomout, zoomin, (t-1.0+clip)/clip, za);
			} else {
				transform.zoom = zoomout;
			}
			
			transform.x = blend(panFromX, panToX, t);
			transform.y = blend(panFromY, panToY, t);
			
			if (firstFrame) {
				lastAutoChange = -1e6;
			}			
			
		}

		if (!updateAnimations(timestamp) && !firstFrame) {
			return;
		}

		setCanvasSize();
		gl.viewport(0, 0, canvas.width, canvas.height);
		gl.clearColor(160/255, 169/255, 175/255, 1.0);
		gl.clear(gl.COLOR_BUFFER_BIT);

		if (timerQuery) {
			if (waitingForTimer) {
				var available = glext.getQueryObjectEXT(timerQuery, glext.QUERY_RESULT_AVAILABLE_EXT);
				var disjoint = gl.getParameter(glext.GPU_DISJOINT_EXT);
				if (available) {
					if (lastFrametime == null || timestamp - lastFrametime > 100) {
						lastFrametime = timestamp;
						var elapsed = glext.getQueryObjectEXT(timerQuery, glext.QUERY_RESULT_EXT);
						document.getElementById("frametime").value = elapsed/1e6;
					}
					waitingForTimer = false;
				}
			}

			if (!waitingForTimer) {
				glext.beginQueryEXT(glext.TIME_ELAPSED_EXT, timerQuery);
			}
		}


		// Draw page backgrounds
		gl.useProgram(pageProgram);
		gl.disable(gl.BLEND);
		var aspect = canvas.height / canvas.width;
		gl.uniform2f(pageProgram.uniforms.uPositionMul, aspect/zoomx, 1/zoomy);
		gl.uniform2f(pageProgram.uniforms.uPositionAdd, aspect * -animTransform.x / zoomx, -animTransform.y / zoomy);
		gl.bindBuffer(gl.ARRAY_BUFFER, pageBuffer);
		enableAttributes(pageProgram);
		gl.vertexAttribPointer(pageProgram.attributes.aPosition, 2, gl.FLOAT, false, 0, 0);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, pageData.length * 6);
		disableAttributes(pageProgram);

		// Draw images
		if (imageBuffer) {
			gl.useProgram(imageProgram);
			gl.bindBuffer(gl.ARRAY_BUFFER, imageBuffer);
			gl.enable(gl.BLEND);
			enableAttributes(imageProgram);
			var bytesPerImageVertex = 10;
			gl.vertexAttribPointer(imageProgram.attributes.aPosition,  2, gl.UNSIGNED_SHORT, true, bytesPerImageVertex, 0);
			gl.vertexAttribPointer(imageProgram.attributes.aTexCoord,  2, gl.UNSIGNED_SHORT, true, bytesPerImageVertex, 4);
			gl.vertexAttribPointer(imageProgram.attributes.aAlpha,     1, gl.UNSIGNED_BYTE,  true, bytesPerImageVertex, 8);
			gl.vertexAttribPointer(imageProgram.attributes.aInvert,    1, gl.UNSIGNED_BYTE,  true, bytesPerImageVertex, 9);

			gl.activeTexture(gl.TEXTURE0);
			gl.uniform1i(imageProgram.uniforms.uSampler, 0);

			for (var i=0; i<pageData.length; i++) {
				if (setPageUniforms(imageProgram, pageData[i], zoomx, zoomy)) {
					var images = pageData[i].images;
					if (images) {
						for (var j=0; j<images.length; j++) {
							var img = images[j];
							var handle = getImageTexture(img.filename);
							if (handle) {
								gl.bindTexture(gl.TEXTURE_2D, handle);
								gl.drawArrays(gl.TRIANGLE_STRIP, img.vertexOffset, img.numVerts);
							}
						}
					}
				}
			}
			disableAttributes(imageProgram);
		}

		// Draw glyphs
		var prog = document.getElementById("vectoronly").checked ? glyphProgramNoRast : glyphProgram;

		gl.useProgram(prog);
		gl.bindBuffer(gl.ARRAY_BUFFER, glyphBuffer);
		gl.enable(gl.BLEND);
		
		enableAttributes(prog);
		doGlyphVertexAttribPointers(prog);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, atlasTexture);
		gl.uniform1i(prog.uniforms.uAtlasSampler, 0);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, preAtlasTexture);
		gl.uniform1i(prog.uniforms.uRasteredAtlasSampler, 1);

		gl.uniform2f(prog.uniforms.uTexelSize, 1/atlasTexture.width, 1/atlasTexture.height);
		gl.uniform2f(prog.uniforms.uRasteredTexelSize, 1/preAtlasTexture.width, 1/preAtlasTexture.height);
		gl.uniform1i(prog.uniforms.uDebug, document.getElementById("showgrids").checked ? 1 : 0);

		for (var i=0; i<pageData.length; i++) {
			var page = pageData[i];
			if (setPageUniforms(prog, page, zoomx, zoomy)) {
				gl.drawArrays(gl.TRIANGLES, page.beginVertex, (page.endVertex - page.beginVertex));
			}
		}		
		disableAttributes(prog);

		if (timerQuery && !waitingForTimer) {
			glext.endQueryEXT(glext.TIME_ELAPSED_EXT);
			waitingForTimer = true;
		}

		lastDrawTime = timestamp;

	}
	var lastDrawTime;

	function tick(timestamp) {
		requestAnimationFrame(tick);
		drawScene(timestamp);
	}
	
	function canvasMouseEnter(e) {
		this.lastX = e.clientX;
		this.lastY = e.clientY;
	}
	
		
	var prevPinchDiff = -1;
	function canvasTouchStart(e) {
		var touch = e.targetTouches[0];
		this.lastX = touch.clientX;
		this.lastY = touch.clientY;
		this.primaryTouchId = touch.identifier;
		prevPinchDiff = -1;
	}

	function handlePinch(ev) {
		var touches = ev.targetTouches;

		if (touches.length == 2) {
		 	var dx = touches[0].clientX - touches[1].clientX;
		 	var dy = touches[0].clientY - touches[1].clientY;

		 	var curDiff = Math.sqrt(dx*dx + dy*dy);

		 	if (prevPinchDiff > 0) {
		 		changeZoom(-(curDiff - prevPinchDiff) / 80, ev);
				finishAnimations();
			}
			prevPinchDiff = curDiff;
		}
	}

	function canvasTouchMove(e) {
		var touch = e.targetTouches[0];


		if (e.targetTouches.length > 1) {
			handlePinch(e);
		} else {
			if (this.primaryTouchId != touch.identifier) {
				this.lastX = touch.clientX;
				this.lastY = touch.clientY;
				this.primaryTouchId = touch.identifier;
			}
	 
			var scaleFactor = 4;
			transform.x -= scaleFactor * ((touch.clientX - this.lastX) / this.offsetWidth) * transform.zoom;
			transform.y += scaleFactor * ((touch.clientY - this.lastY) / this.offsetHeight) * transform.zoom;
			
			finishAnimations();
		}

		this.lastX = touch.clientX;
		this.lastY = touch.clientY;

		e.preventDefault();
	}

	function canvasMouseMove(e) {
		var btn = e.buttons;
		if (btn == null) {
			btn = e.which;
			if (btn == 3) btn = 2;
		}

		if (btn) {
			if (e.altKey || btn == 2) {
				var dx, dy;
				if (document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement) {
					dx = e.movementX;
					dy = e.movementY;
				} else {
					dx = e.clientX - this.lastX;
					dy = e.clientY - this.lastY;
				}
				var dmax = Math.abs(dx) > Math.abs(dy) ? -dx : dy;
				changeZoom(7.0 * (dmax / this.offsetHeight), e);
			} else {
				var scaleFactor = 5.5;
				transform.x -= scaleFactor * ((e.clientX - this.lastX) / this.offsetWidth) * transform.zoom;
				transform.y += scaleFactor * ((e.clientY - this.lastY) / this.offsetHeight) * transform.zoom;
			}
		}

		this.lastX = e.clientX;
		this.lastY = e.clientY;
	}
	
	function changeZoom(amount, e) {
		var x=0, y=0;
		if (e && e.clientX != null) {
			var mul = 1;
			if (window.innerWidth && window.outerWidth) {
				mul = window.outerWidth / window.innerWidth;
			}

			x = e.clientX * mul / e.target.clientWidth * 2 - 1;
			y = 1 - e.clientY * mul / e.target.clientHeight * 2;
		}

		var zoomx = transform.zoom;
		var zoomy = zoomx * pageData[0].width / pageData[0].height;

		var worldx = x * canvas.width / canvas.height * zoomx + transform.x;
		var worldy = y * zoomy + transform.y;

		// Change coords and keep world position under cursor
		transform.zoom *= Math.pow(2, amount);

		zoomx = transform.zoom;
		zoomy = zoomx * pageData[0].width / pageData[0].height;

		transform.x = worldx - x * canvas.width / canvas.height * zoomx;
		transform.y = worldy - y * zoomy;
	}

	function canvasMouseWheel(e) {
		var amt = e.deltaY;
		if (e.deltaMode == 1) amt *= 30;
		if (e.deltaMode == 2) amt *= 1000;
		changeZoom(amt/200);

		e.preventDefault();
	}
	

	function fullscreen() {
		var e = document.getElementById("canvaswrap")
		if (e.requestFullscreen) {
			e.requestFullscreen();
		} else if (e.webkitRequestFullScreen) {
			e.webkitRequestFullScreen();
		} else if (e.mozRequestFullScreen) {
			e.mozRequestFullScreen();
		} else if (canvas.msRequestFullscreen) {
			e.msRequestFullscreen();
		}

		forceAnimationChange();
	}
	
	function uncached(s) {
		if (document.location.hostname == "localhost") {
			return s + "?" + Math.random();
		}
		return s;
	}

	function webGlStart() {
		
		canvas = document.getElementById("beziercanvas");
		canvas.addEventListener("touchmove", canvasTouchMove);
		canvas.addEventListener("touchstart", canvasTouchStart);
		canvas.addEventListener("mousemove", canvasMouseMove);
		canvas.addEventListener("mouseenter", canvasMouseEnter);
		canvas.addEventListener("wheel", canvasMouseWheel);
		canvas.addEventListener("contextmenu", function(e) {e.preventDefault()}, false);
		canvas.addEventListener("mousedown", function(e) {
			if (e.button == 2 || e.buttons == 2) {
				canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock ||
										 	canvas.webkitRequestPointerLock;

			 	canvas.requestPointerLock();
			 }
		});
		canvas.addEventListener("mouseup", function(e) {
			document.exitPointerLock = document.exitPointerLock ||
									   document.mozExitPointerLock ||
								   	   document.webkitExitPointerLock;
	   	   document.exitPointerLock();
		});

		window.addEventListener("resize", forceAnimationChange);

		initGl();

		// Shader programs
		log("Compiling shaders...");
    	imageProgram = createProgram("imagevs", "imagefs");
    	glyphProgram = createProgram("glyphvs", "glyphfs", "#define kUseRasteredAtlas\n");
    	glyphProgramNoRast = createProgram("glyphvs", "glyphfs");
    	pageProgram = createProgram("pagevs", "pagefs");

		log("Loading files...");
		requestFile("glyphs.bmp", processGlyphs, "arraybuffer");
		requestFile("atlas.bmp", processAtlas, "arraybuffer");
		requestFile('pages.json', processPageData);
		requestFile('imageverts.bmp', processImageVertices, "arraybuffer");


		tick();

	}

	function go() {
		if (window.navigator.userAgent.indexOf("Trident") >= 0 || window.navigator.userAgent.indexOf("Edge") >= 0) {
			log("The shader is currently very, very, very, very slow to compile on Microsoft browsers. Hold tight..");
			setTimeout(webGlStart, 200);
		} else {
			webGlStart();
		}
	}

</script>
</head>
<body onload="go()">
<div id="canvaswrap"><canvas id="beziercanvas"></canvas></div>
<div id="toolbar">
<a href="/post/war-and-peace-and-webgl/">Resolution independent GPU text rendering</a><br>
Drag to pan, right mouse (or alt) drag to zoom
<p>
<label><input type="checkbox" checked id="autopan">Auto zoom</label>
<label><input type="checkbox" id="showgrids" onchange="forceAnimationChange()">Grids</label>
<label><input type="checkbox" id="vectoronly" onchange="forceAnimationChange()">Vector only</label>
<input type="button" id="fsbutton" value="Fullscreen" onclick="fullscreen()">
<input id="frametime" style="display: none">
</div>
<div id="loadinginfo"></div>
</body>
</html>

